// src/lib/geminiMeal.ts

import {
    GoogleGenerativeAI,
    GenerationConfig,
    SafetySetting,
    HarmCategory,
    HarmBlockThreshold,
} from '@google/generative-ai';

// --- Appwrite Type Imports ---
import { UserProfile } from './appwrite'; // Adjust path if necessary

// --- Import the central Gemini service ---
import geminiService, { AppChatMessage } from './gemini';

// --- Constants for Type Validation (Unchanged) ---

/** Valid meal types allowed in the MealIdea interface. */
export const VALID_MEAL_TYPES = ["Breakfast", "Lunch", "Dinner", "Snack", "Dessert"] as const;
/** Union type representing allowed meal types. */
export type MealType = typeof VALID_MEAL_TYPES[number];

/** Valid recipe complexity levels. */
export const VALID_RECIPE_COMPLEXITY = ["Easy", "Medium", "Hard"] as const;
/** Union type representing allowed recipe complexities. */
export type RecipeComplexity = typeof VALID_RECIPE_COMPLEXITY[number];

// --- Interface Definitions (Unchanged) ---

/** Represents a single meal idea generated by the AI. */
export interface MealIdea {
  id: string;
  name: string;
  description: string;
  mealType: MealType | string;
  keyIngredients?: string[];
  dietaryNotes?: string[];
  prepTime?: string;
  cookingTime?: string;
  recipeComplexity?: RecipeComplexity | string;
  servingSize?: string;
  macros?: string;
  preparationSteps?: string[];
  reasoning?: string;
}

/** Structure for the AI's response, specialized for meals */
export interface PersonalizedMealContent {
  meals: MealIdea[];
}

/** Options to customize the meal generation request */
export interface MealGenerationOptions {
  count?: number;
  customPreference?: string;
}

// --- Configuration ---
// The API key and model initialization are now handled centrally in `gemini.ts`

/** Configuration settings for this specific AI generation task. */
const generationConfig: GenerationConfig = {
    temperature: 0.7,
    maxOutputTokens: 4096, // Sufficient for detailed JSON output
    topP: 0.9,
    // Gemini supports JSON output mode directly, which is more reliable
    responseMimeType: "application/json",
};

// --- Helper Functions (Unchanged Logic) ---

/** Helper to get basic trimester info based on weeks pregnant. */
const getTrimesterInfo = (weeks: number | string | undefined | null): string => {
    const numWeeks = parseInt(String(weeks), 10);
    if (isNaN(numWeeks) || numWeeks < 1) return "Pregnancy stage unknown";
    if (numWeeks <= 13) return "First trimester";
    if (numWeeks <= 27) return "Second trimester";
    if (numWeeks <= 42) return "Third trimester";
    return "Post-term or invalid weeks";
};

/**
 * Creates the detailed prompt for the AI based on user profile and options.
 * This function's logic is AI-provider agnostic and remains the same.
 */
const createMealPersonalizationPrompt = (profile: UserProfile, options: MealGenerationOptions = {}): string => {
    const { count = 3, customPreference } = options;
    const weeks = profile.weeksPregnant ?? 'unknown';
    const activity = profile.activityLevel ?? 'unspecified';
    const conditions = profile.preExistingConditions?.trim() || 'none specified';
    const diet = profile.dietaryPreferences?.length ? profile.dietaryPreferences.join(', ') : 'none specified';

    let context = `**User Context:**\n`;
    context += `- Pregnancy Stage: ${weeks} weeks (Implications: ${getTrimesterInfo(weeks)})\n`;
    context += `- Stated Activity Level: ${activity}\n`;
    context += `- Stated Dietary Preferences: ${diet}\n`;
    if (conditions !== 'none specified') {
        context += `- Stated Pre-existing Conditions: ${conditions} (Acknowledge for context only, DO NOT give medical advice related to these)\n`;
    }
    if (customPreference?.trim()) {
        context += `- User's Current Meal Request/Focus: "${customPreference.trim()}"\n`;
    }
    if (weeks === 'unknown' && activity === 'unspecified' && diet === 'none specified' && conditions === 'none specified') {
        context += `- Note: User profile context is minimal. Provide generally safe and helpful pregnancy meal suggestions.\n`;
    }

    const safetyInstructions = `
**Safety & Role Definition:**
- You are MamaSaheli, an informational assistant providing general meal suggestions. You are **NOT** a medical professional. Your advice is not a substitute for professional consultation.
- **ALL meal suggestions are purely informational and MUST NOT be taken as medical or professional dietary advice.**
- **CRITICAL (Meal Safety):** For **every** meal suggestion, the "description" or "reasoning" **MUST** clearly state that it's a general idea and individual dietary needs vary. Advise the user to consult their healthcare provider. Macros provided are **estimates only**.
- Base suggestions on general, evidence-based knowledge about pregnancy nutritional needs (e.g., folate, iron, calcium).
- Consider common pregnancy food safety guidelines (e.g., avoiding raw/undercooked items).
- **DO NOT** suggest specific supplement dosages or brands.
- **DO NOT** attempt to diagnose or treat any medical conditions.
`;

    const outputFormatInstructions = `
**Output Format Instructions:**
Provide the response STRICTLY as a valid JSON object. The top-level JSON object MUST ONLY have a single key: "meals". The value of "meals" MUST be an array of Meal Idea objects.

Generate approximately ${count} valid meal suggestions.

**Meal Idea Object Structure (within "meals" array):**
- "id": (string) A unique identifier (e.g., "meal-1").
- "name": (string) Catchy and descriptive name.
- "description": (string) 1-3 sentences. Use Markdown. **Must include the disclaimer about consulting a professional.**
- "mealType": (string) Must be one of: ${VALID_MEAL_TYPES.join(', ')}.
- "keyIngredients": (array of strings) List 3-5 main ingredients.
- "dietaryNotes": (array of strings, optional) e.g., ["Vegetarian"].
- "prepTime": (string, optional) e.g., "Approx. 15 mins".
- "cookingTime": (string, optional) e.g., "Approx. 30 mins".
- "recipeComplexity": (string) Must be one of: ${VALID_RECIPE_COMPLEXITY.join(', ')}.
- "servingSize": (string, optional) e.g., "Serves 2-3".
- "macros": (string, optional) Estimated macros, e.g., "Approx. P: 30g, C: 50g, F: 18g". **Must state these are estimates.**
- "preparationSteps": (array of strings) Clear, step-by-step instructions.
- "reasoning": (string, optional) Max 20 words on relevance.

**CRITICAL Rules:**
- **Output ONLY the JSON object string.** No introductory text or markdown formatting.
- Adhere STRICTLY to the requested JSON structure.
- Ensure valid JSON syntax (double quotes for all keys and string values).
- Ensure all mandatory fields are present and non-empty.
`;

    return `
You are MamaSaheli, an informational assistant. Provide safe, general meal suggestions based on the user's profile, adhering strictly to safety guidelines and the required JSON output format.

${context}
${safetyInstructions}
Generate personalized meal ideas based *specifically* on the user's context. Adhere precisely to the output format instructions below.
${outputFormatInstructions}
`;
};

/**
 * Parses and validates the AI's JSON response for meal ideas.
 * This function is provider-agnostic and remains the same.
 */
const parseAndValidateMealContent = (responseText: string): PersonalizedMealContent => {
    let cleanedJsonString = responseText.trim();
    // Gemini's JSON mode is cleaner, but this is a good safeguard.
    const jsonStartIndex = cleanedJsonString.indexOf('{');
    const jsonEndIndex = cleanedJsonString.lastIndexOf('}');
    if (jsonStartIndex === -1 || jsonEndIndex === -1 || jsonEndIndex < jsonStartIndex) {
        throw new Error("AI response did not contain a recognizable JSON object.");
    }
    cleanedJsonString = cleanedJsonString.substring(jsonStartIndex, jsonEndIndex + 1);

    let parsedData: unknown;
    try {
        parsedData = JSON.parse(cleanedJsonString);
    } catch (parseError: unknown) {
        throw new Error(`Failed to parse AI suggestions. Invalid JSON format. ${parseError instanceof Error ? `Details: ${parseError.message}` : ''}`);
    }

    if (typeof parsedData !== 'object' || parsedData === null) {
        throw new Error("Validation Error: AI response is not a JSON object.");
    }

    const potentialContent = parsedData as Record<string, unknown>;
    const validatedOutput: PersonalizedMealContent = { meals: [] };

    if (!Object.prototype.hasOwnProperty.call(potentialContent, 'meals') || !Array.isArray(potentialContent.meals)) {
        throw new Error("Validation Error: AI response missing required 'meals' array.");
    }

    validatedOutput.meals = potentialContent.meals
        .map((item: unknown): MealIdea | null => {
            if (typeof item !== 'object' || item === null) return null;
            const meal = item as Record<string, unknown>;

            if (typeof meal.id !== 'string' || !meal.id.trim() ||
                typeof meal.name !== 'string' || !meal.name.trim() ||
                typeof meal.description !== 'string' || !meal.description.trim() ||
                typeof meal.mealType !== 'string' || !meal.mealType.trim() ||
                !Array.isArray(meal.preparationSteps)) {
                return null;
            }

            const keyIngredients = Array.isArray(meal.keyIngredients) ? meal.keyIngredients.filter((k): k is string => typeof k === 'string' && !!k.trim()) : [];
            const dietaryNotes = Array.isArray(meal.dietaryNotes) ? meal.dietaryNotes.filter((n): n is string => typeof n === 'string' && !!n.trim()) : [];
            const preparationSteps = meal.preparationSteps.filter((s): s is string => typeof s === 'string' && !!s.trim());
            const finalComplexity = VALID_RECIPE_COMPLEXITY.includes(meal.recipeComplexity as RecipeComplexity) ? meal.recipeComplexity as RecipeComplexity : "Easy";
            const finalMealType = VALID_MEAL_TYPES.includes(meal.mealType as MealType) ? meal.mealType : "Snack";

            return {
                id: meal.id.trim(),
                name: meal.name.trim(),
                description: meal.description.trim(),
                mealType: finalMealType,
                keyIngredients,
                dietaryNotes,
                prepTime: (typeof meal.prepTime === 'string' && meal.prepTime.trim()) ? meal.prepTime.trim() : undefined,
                cookingTime: (typeof meal.cookingTime === 'string' && meal.cookingTime.trim()) ? meal.cookingTime.trim() : undefined,
                recipeComplexity: finalComplexity,
                servingSize: (typeof meal.servingSize === 'string' && meal.servingSize.trim()) ? meal.servingSize.trim() : undefined,
                macros: (typeof meal.macros === 'string' && meal.macros.trim()) ? meal.macros.trim() : undefined,
                preparationSteps,
                reasoning: (typeof meal.reasoning === 'string' && meal.reasoning.trim()) ? meal.reasoning.trim() : undefined,
            };
        })
        .filter((item): item is MealIdea => item !== null);

    if (validatedOutput.meals.length === 0 && potentialContent.meals.length > 0) {
       console.warn("Validation Warning: AI 'meals' array contained items, but none passed validation.");
    }

    return validatedOutput;
};


// --- Public API Function (Updated for Gemini) ---

/**
 * Fetches personalized meal suggestions from the Gemini API.
 */
export const generatePersonalizedMeals = async (
    profile: UserProfile,
    options: MealGenerationOptions = {}
): Promise<PersonalizedMealContent> => {
    if (!geminiService) {
        throw new Error("Meal suggestion service unavailable (Gemini client not initialized). Check API Key.");
    }

    const prompt = createMealPersonalizationPrompt(profile, options);
    // For Gemini, we use a system prompt and a simple user prompt to trigger it.
    const messages: AppChatMessage[] = [
        { role: 'system', content: prompt },
        { role: 'user', content: 'Please generate the meal suggestions now in the specified JSON format.' }
    ];

    try {
        console.log("Requesting meal suggestions from Gemini...");
        // Call the central geminiService, passing our specialized generation config
        const responseText = await geminiService.sendMessage(
            messages
        );

        if (!responseText?.trim()) {
             console.warn("Gemini returned an empty response. Returning empty suggestions.");
             return { meals: [] };
        }

        return parseAndValidateMealContent(responseText);

    } catch (error: unknown) {
        console.error(`Error during Gemini meal personalization fetch/parse:`, error);
        if (error instanceof Error) {
            throw new Error(`Meal personalization service API error: ${error.message}`);
        } else {
            throw new Error("An unexpected error occurred while fetching personalized meal content.");
        }
    }
};

// --- Service Object Export (Renamed) ---
export const geminiMealService = {
    generatePersonalizedMeals,
};